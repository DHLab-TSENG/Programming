{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"7. Visualization\"\n",
        "author: \"Yi-Ju Tseng\"\n",
        "format:\n",
        "  revealjs:\n",
        "    slide-number: c/t\n",
        "    show-slide-number: all\n",
        "editor: visual\n",
        "---\n",
        "\n",
        "\n",
        "# Visualization\n",
        "\n",
        "-   Visualization with Matplotlib\n",
        "-   Simple Line Plots with Matplotlib\n",
        "-   Simple Scatter Plots with Matplotlib\n",
        "-   Visualizing Errors with Matplotlib\n",
        "-   Density and Contour Plots in Matplotlib\n",
        "-   Histograms, Binnings, and Density\n",
        "-   Customizing Plot Legends in Matplotlib\n",
        "-   Customizing Colorbars in Matplotlib\n",
        "-   Multiple Subplots in Matplotlib\n",
        "-   Text and Annotation in Matplotlib\n",
        "-   Configurations and Stylesheets\n",
        "-   Geographic Data Visualization with Basemap\n",
        "-   Visualization with Seaborn\n",
        "\n",
        "# Visualization with Matplotlib\n",
        "\n",
        "## What is Matplotlib?\n",
        "\n",
        "-   Matplotlib is a multi-platform **data visualization library** for Python\n",
        "-   Created by John Hunter in 2002, with version 0.1 released in 2003.\n",
        "-   Large user and developer base, making it a powerful and ubiquitous tool for scientific visualization.\n",
        "-   Despite newer visualization tools, Matplotlib remains a vital part of the data science stack.\n",
        "\n",
        "## Importing Matplotlib\n"
      ],
      "id": "e7cddaf4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib as mpl\n",
        "import matplotlib.pyplot as plt"
      ],
      "id": "62a36659",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `plt` interface is most commonly used.\n",
        "\n",
        "## Setting Plot Styles\n",
        "\n",
        "Use `plt.style.use('style')` to set the visual style of your plots\n"
      ],
      "id": "02b7b690"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.style.use('classic')"
      ],
      "id": "1f7a99a8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "[Stylesheets](https://matplotlib.org/stable/gallery/style_sheets/style_sheets_reference.html)\n",
        "\n",
        "## How to View Your Plots - (1/2)\n",
        "\n",
        "-   **From a Python script:**\\\n",
        "    Use `plt.show()` once at the end of your script to display all figures.\n"
      ],
      "id": "79724945"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "x = np.linspace(0, 10, 100)\n",
        "plt.plot(x, np.sin(x))\n",
        "plt.plot(x, np.cos(x))\n",
        "plt.show()"
      ],
      "id": "9a4aa07d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## How to View Your Plots - (2/2)\n",
        "\n",
        "-   **From an IPython shell:**\\\n",
        "    Use `%matplotlib` magic command to enable interactive plotting.\\\n",
        "    `plt.show()` is not required.\n",
        "\n",
        "-   **From a Jupyter (IPython) notebook:**\\\n",
        "    Use `%matplotlib inline` for static images or `%matplotlib notebook` for interactive plots.\n"
      ],
      "id": "4fe86fb7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "%matplotlib inline\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "x = np.linspace(0, 10, 100)\n",
        "fig = plt.figure()\n",
        "plt.plot(x, np.sin(x), '-')\n",
        "plt.plot(x, np.cos(x), '--');"
      ],
      "id": "97e6d912",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Saving Figures\n",
        "\n",
        "Save figures using `.savefig()`:\n"
      ],
      "id": "0fc925b8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig.savefig('my_figure.png')"
      ],
      "id": "7a51503e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   File format is inferred from the file extension.\n",
        "-   Supported formats include: PNG, JPG, PDF, SVG, TIFF, and more.\n"
      ],
      "id": "dfad4ad0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig.canvas.get_supported_filetypes()"
      ],
      "id": "0e3739e2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Summary\n",
        "\n",
        "-   Matplotlib is the foundational Python library for data visualization.\n",
        "-   Offers flexibility, cross-platform compatibility, and supports many output formats.\n",
        "-   Integrates well with scripts, IPython shells, and Jupyter notebooks.\n",
        "\n",
        "# Simple Line Plots with Matplotlib\n",
        "\n",
        "## Getting Started: Setup\n",
        "\n",
        "Import necessary packages and set the plotting style\n"
      ],
      "id": "82ac2d91"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "%matplotlib inline\n",
        "import matplotlib.pyplot as plt\n",
        "plt.style.use('seaborn-whitegrid')\n",
        "import numpy as np"
      ],
      "id": "7e0ca7c0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Creating a Figure and Axes\n",
        "\n",
        "a **figure** is the overall window or page, and **axes** are the plotting area.\n"
      ],
      "id": "7ecf0fcf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig = plt.figure()\n",
        "ax = plt.axes()"
      ],
      "id": "2f089990",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   `fig` is a Figure instance (container for all plot elements).\n",
        "-   `ax` is an Axes instance (the actual plot area).\n",
        "\n",
        "## Plotting a Simple Function\n",
        "\n",
        "Example: Plotting a sine curve\n"
      ],
      "id": "7950103e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, np.sin(x))"
      ],
      "id": "5636d86a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Multiple Lines in One Plot\n",
        "\n",
        "Call `plot` multiple times to overlay lines:\n"
      ],
      "id": "ed3d4d1e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, np.sin(x))\n",
        "plt.plot(x, np.cos(x))"
      ],
      "id": "9afab367",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Customizing Line Color and Style\n",
        "\n",
        "**Color options:**\n"
      ],
      "id": "32e868e1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, np.sin(x - 0), color='blue')        # by name\n",
        "plt.plot(x, np.sin(x - 1), color='g')           # short code (r, g, b, c, m, y, k)\n",
        "plt.plot(x, np.sin(x - 2), color='0.75')        # grayscale\n",
        "plt.plot(x, np.sin(x - 3), color='#FFDD44')     # hex code\n",
        "plt.plot(x, np.sin(x - 4), color=(1.0,0.2,0.3)) # RGB tuple\n",
        "plt.plot(x, np.sin(x - 5), color='chartreuse')  # HTML color name"
      ],
      "id": "5d4612ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Customizing Line Color and Style\n",
        "\n",
        "**Line styles:**\n"
      ],
      "id": "8a0a1662"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, x + 0, linestyle='solid')\n",
        "plt.plot(x, x + 1, linestyle='dashed')\n",
        "plt.plot(x, x + 2, linestyle='dashdot')\n",
        "plt.plot(x, x + 3, linestyle='dotted')\n",
        "# Short codes:\n",
        "plt.plot(x, x + 4, linestyle='-')   # solid\n",
        "plt.plot(x, x + 5, linestyle='--')  # dashed\n",
        "plt.plot(x, x + 6, linestyle='-.')  # dashdot\n",
        "plt.plot(x, x + 7, linestyle=':')   # dotted"
      ],
      "id": "ef00c523",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Customizing Line Color and Style\n",
        "\n",
        "**Combine color and style:**\n"
      ],
      "id": "4c78e157"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, x + 0, '-g')  # solid green\n",
        "plt.plot(x, x + 1, '--c') # dashed cyan\n",
        "plt.plot(x, x + 2, '-.k') # dashdot black\n",
        "plt.plot(x, x + 3, ':r')  # dotted red"
      ],
      "id": "55ed50ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Adjusting Axes Limits\n",
        "\n",
        "Set axis limits:\n"
      ],
      "id": "b28aea9f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, np.sin(x))\n",
        "plt.xlim(-1, 11)\n",
        "plt.ylim(-1.5, 1.5)"
      ],
      "id": "1651844d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Reverse axis direction:\n"
      ],
      "id": "c904701b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.xlim(10, 0)\n",
        "plt.ylim(1.2, -1.2)"
      ],
      "id": "5a7d27ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Adjusting Axes Limits\n",
        "\n",
        "Use `plt.axis()` for more control:\n"
      ],
      "id": "23c132e9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.axis([-1, 11, -1.5, 1.5])   # [xmin, xmax, ymin, ymax]\n",
        "plt.axis('tight')               # tight bounds\n",
        "plt.axis('equal')               # equal aspect ratio"
      ],
      "id": "ee484f1c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Adding Titles, Labels, and Legends\n",
        "\n",
        "Set plot title and axis labels:\n"
      ],
      "id": "8987b5f7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, np.sin(x))\n",
        "plt.title(\"A Sine Curve\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"sin(x)\")"
      ],
      "id": "3b410f83",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Adding Titles, Labels, and Legends\n",
        "\n",
        "Add a legend for multiple lines:\n"
      ],
      "id": "c2f63563"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, np.sin(x), '-g', label='sin(x)')\n",
        "plt.plot(x, np.cos(x), ':b', label='cos(x)')\n",
        "plt.axis('equal')\n",
        "plt.legend()"
      ],
      "id": "72f15000",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Summary\n",
        "\n",
        "-   Use plt.plot() for quick line plots.\n",
        "-   Customize appearance with color, line style, axis limits, titles, labels, and legends.\n",
        "\n",
        "# Simple Scatter Plots with Matplotlib\n",
        "\n",
        "## What is a Scatter Plot?\n",
        "\n",
        "-   A scatter plot displays individual data points as dots, circles, or other shapes, rather than connecting them with lines.\n",
        "-   Useful for visualizing the relationship between two or more variables.\n",
        "\n",
        "## Setup\n"
      ],
      "id": "560831c9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "%matplotlib inline\n",
        "import matplotlib.pyplot as plt\n",
        "plt.style.use('seaborn-whitegrid')\n",
        "import numpy as np"
      ],
      "id": "cf45fded",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Scatter Plots with `plt.plot`\n",
        "\n",
        "The `plt.plot` function can create scatter plots by specifying a marker style.\n"
      ],
      "id": "8d2dcae4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "x = np.linspace(0, 10, 30)\n",
        "y = np.sin(x)\n",
        "plt.plot(x, y, 'o', color='black')"
      ],
      "id": "e76583b4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   The third argument (`'o'`) sets the marker shape. \n",
        "    -   `'o'`, `'.'`, `','`, `'x'`, `'+'`, `'v'`, `'^'`, `''`, `'s'`, `'d'`, etc.\n",
        "\n",
        "## Scatter Plots - marker shape\n"
      ],
      "id": "37dae923"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "rng = np.random.RandomState(0)\n",
        "for marker in ['o', '.', ',', 'x', '+', 'v', '^', '', 's', 'd']:\n",
        "    plt.plot(rng.rand(5), rng.rand(5), marker, label=f\"marker='{marker}'\")\n",
        "plt.legend(numpoints=1)\n",
        "plt.xlim(0, 1.8)"
      ],
      "id": "c62788a6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Line styles and marker shape\n",
        "\n",
        "Combine marker and line styles for more complex plots:\n"
      ],
      "id": "514ca2cc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, y, '-ok')"
      ],
      "id": "60c6c68d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Line styles and marker shape\n",
        "\n",
        "Customize markers and lines with additional arguments:\n"
      ],
      "id": "b5f45ae0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, y, '-p', color='gray',\n",
        "         markersize=15, linewidth=4,\n",
        "         markerfacecolor='white',\n",
        "         markeredgecolor='gray',\n",
        "         markeredgewidth=2)\n",
        "plt.ylim(-1.2, 1.2)"
      ],
      "id": "26460b81",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Scatter Plots with `plt.scatter`\n",
        "\n",
        "-   The `plt.scatter` function is more powerful and flexible, allowing individual control over each point's size, color, and other properties.\n"
      ],
      "id": "6e2416f0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.scatter(x, y, marker='o')"
      ],
      "id": "038a0f63",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## with varying color and size\n",
        "\n",
        " `c` sets the color for each point, `s` sets the size, `alpha` controls transparency, and `cmap` sets the colormap.\n"
      ],
      "id": "a03aa51a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "rng = np.random.RandomState(0)\n",
        "x = rng.randn(100)\n",
        "y = rng.randn(100)\n",
        "colors = rng.rand(100)\n",
        "sizes = 1000 * rng.rand(100)\n",
        "\n",
        "plt.scatter(x, y, c=colors, s=sizes, alpha=0.3, cmap='viridis')\n",
        "plt.colorbar()  # Show color scale"
      ],
      "id": "e2802777",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Visualizing Multidimensional Data\n",
        "\n",
        "Example: Iris dataset from Scikit-Learn, visualizing four features at once.\n"
      ],
      "id": "c025afcd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from sklearn.datasets import load_iris\n",
        "iris = load_iris()\n",
        "features = iris.data.T\n",
        "\n",
        "plt.scatter(features, features, alpha=0.2,\n",
        "            s=100*features, c=iris.target, cmap='viridis')\n",
        "plt.xlabel(iris.feature_names)\n",
        "plt.ylabel(iris.feature_names)"
      ],
      "id": "39dac938",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "x/y positions, size, and color all encode different data dimensions.\n",
        "\n",
        "------------------------------------------------------------------------\n",
        "\n",
        "## `plot` vs. `scatter`: Efficiency Note\n",
        "\n",
        "-   For small datasets, both `plt.plot` and `plt.scatter` work well.\n",
        "-   For large datasets (thousands of points or more), `plt.plot` is more efficient because all points are rendered with the same style.\n",
        "-   `plt.scatter` is less efficient for large datasets since it allows per-point customization and must render each point individually.\n",
        "\n",
        "\n",
        "# Visualizing Errors with Matplotlib\n",
        "\n",
        "## Why Show Error Bars?\n",
        "\n",
        "-   Error bars represent the uncertainty or variability in your data.\n",
        "-   They help communicate the reliability and precision of measurements.\n",
        "-   For example, reporting a measurement as $$74 \\pm 5$$ is much more informative than just 74.\n",
        "\n",
        "\n",
        "## Basic Error Bars with `plt.errorbar`\n",
        "\n",
        "The `plt.errorbar` function is used to add error bars to your plots.\n",
        "\n",
        "-   `yerr` specifies the vertical error bar size.\n",
        "-   `fmt` controls the marker and line style (same as in `plt.plot`).\n"
      ],
      "id": "e9871b36"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "x = np.linspace(0, 10, 50)\n",
        "dy = 0.8\n",
        "y = np.sin(x) + dy * np.random.randn(50)\n",
        "\n",
        "plt.errorbar(x, y, yerr=dy, fmt='.k')\n",
        "plt.show()"
      ],
      "id": "21116709",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Customizing Error Bars\n",
        "\n",
        "You can adjust the appearance for clarity, especially in crowded plots:\n",
        "\n",
        "-   `ecolor`: color of the error bars\n",
        "-   `elinewidth`: width of error bar lines\n",
        "-   `capsize`: size of the error bar caps\n"
      ],
      "id": "878657fb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.errorbar(\n",
        "    x, y, yerr=dy, fmt='o', color='black',\n",
        "    ecolor='lightgray', elinewidth=3, capsize=0\n",
        ")\n",
        "plt.show()"
      ],
      "id": "452e6f15",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Horizontal and One-Sided Error Bars\n",
        "\n",
        "Add horizontal error bars using `xerr`:\n",
        "\n",
        "-   You can combine `xerr` and `yerr` for both directions\n"
      ],
      "id": "19e0c08f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.errorbar(x, y, xerr=0.5, fmt='o')"
      ],
      "id": "c27e5b9a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Visualizing Continuous Errors\n",
        "\n",
        "-   For continuous uncertainty (e.g., model predictions), use `plt.fill_between` to shade the confidence region:\n"
      ],
      "id": "db6522f9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(xdata, ydata, 'or')\n",
        "plt.plot(xfit, yfit, '-', color='gray')\n",
        "plt.fill_between(xfit, yfit - dyfit, yfit + dyfit, color='gray', alpha=0.2)\n",
        "plt.xlim(0, 10)\n",
        "plt.show()"
      ],
      "id": "9efd0109",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   This approach visually communicates where the model is more or less certain.\n",
        "\n",
        "## Summary Table: Common Error Bar Options\n",
        "\n",
        "| Parameter    | Description                            |\n",
        "|--------------|----------------------------------------|\n",
        "| `yerr`       | Vertical error bar sizes               |\n",
        "| `xerr`       | Horizontal error bar sizes             |\n",
        "| `fmt`        | Format string for marker/line style    |\n",
        "| `ecolor`     | Color of error bars                    |\n",
        "| `elinewidth` | Line width of error bars               |\n",
        "| `capsize`    | Size of caps at the ends of error bars |\n",
        "\n",
        "\n",
        "## Key Takeaways\n",
        "\n",
        "-   Use error bars to show uncertainty in your data.\n",
        "-   `plt.errorbar` is flexible and customizable for both simple and advanced needs.\n",
        "-   For continuous error regions, use `plt.fill_between` for a more intuitive visualization\n",
        "-   See the [Matplotlib documentation](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.errorbar.html) for more options.\n",
        "\n",
        "# Density and Contour Plots in Matplotlib\n",
        "\n",
        "## Introduction\n",
        "\n",
        "-   Density and contour plots are useful for visualizing three-dimensional data in two dimensions using contours (lines) or color-coded regions.\n",
        "-   Matplotlib provides three main functions for this purpose:\n",
        "    -   `plt.contour` for contour lines\n",
        "    -   `plt.contourf` for filled contours\n",
        "    -   `plt.imshow` for displaying images\n",
        "\n",
        "\n",
        "## Setting Up\n"
      ],
      "id": "9806f7d6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "%matplotlib inline\n",
        "import matplotlib.pyplot as plt\n",
        "plt.style.use('seaborn-white')\n",
        "import numpy as np"
      ],
      "id": "54bc3dfb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Creating a Contour Plot\n",
        "\n",
        "-   Contour plots require a function $$ z = f(x, y) $$ evaluated on a grid.\n",
        "-   Use `np.meshgrid` to create the grid:\n"
      ],
      "id": "bc9edb89"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "def f(x, y):\n",
        "    return np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)\n",
        "\n",
        "x = np.linspace(0, 5, 50)\n",
        "y = np.linspace(0, 5, 40)\n",
        "X, Y = np.meshgrid(x, y)\n",
        "Z = f(X, Y)"
      ],
      "id": "76d9ce17",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##  Basic contour plot:\n"
      ],
      "id": "f6658076"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.contour(X, Y, Z, colors='black')"
      ],
      "id": "d0d8ffb2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "By default, negative values are dashed lines, positive values are solid lines\\[1\\].\n",
        "\n",
        "\n",
        "\n",
        "## Color-Coded Contour Plot\n",
        "\n",
        "Use the `cmap` argument to specify a colormap and increase the number of contour levels:\n"
      ],
      "id": "e049bc47"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.contour(X, Y, Z, 20, cmap='RdGy')"
      ],
      "id": "8d818264",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`RdGy` is a good colormap for centered data. Matplotlib offers many colormaps (see `plt.cm.` in IPython for options)\n",
        "\n",
        "\n",
        "## Filled Contour Plot\n",
        "\n",
        "Use `plt.contourf` for filled contours and add a colorbar for reference:\n"
      ],
      "id": "329ab7c1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.contourf(X, Y, Z, 20, cmap='RdGy')\n",
        "plt.colorbar()"
      ],
      "id": "fea0ec9d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The colorbar shows the mapping between color and data values\\[1\\].\n",
        "\n",
        "\n",
        "## Displaying Data as an Image\n",
        "\n",
        "For a smoother appearance, use `plt.imshow` to display the grid as an image:\n"
      ],
      "id": "99dceeb7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower', cmap='RdGy')\n",
        "plt.colorbar()\n",
        "plt.axis(aspect='image')"
      ],
      "id": "e63e993d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note: `imshow` requires manual setting of plot extent and origin\\[1\\].\n",
        "\n",
        "\n",
        "## Combining Contour and Image Plots\n",
        "\n",
        "Overlay contours on an image for richer visualization:\n"
      ],
      "id": "ae9b41a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "contours = plt.contour(X, Y, Z, 3, colors='black')\n",
        "plt.clabel(contours, inline=True, fontsize=8)\n",
        "plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower', cmap='RdGy', alpha=0.5)\n",
        "plt.colorbar()"
      ],
      "id": "cc8fd0bf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Use `plt.clabel` to label contour lines\\[1\\].\n",
        "\n",
        "\n",
        "## Summary Table: Key Functions\n",
        "\n",
        "| Function       | Description                     |\n",
        "|----------------|---------------------------------|\n",
        "| `plt.contour`  | Draws contour lines             |\n",
        "| `plt.contourf` | Draws filled contours           |\n",
        "| `plt.imshow`   | Displays a 2D array as an image |\n",
        "| `plt.colorbar` | Adds a colorbar to the plot     |\n",
        "| `plt.clabel`   | Adds labels to contour lines    |\n",
        "\n",
        "\n",
        "## Tips and Notes\n",
        "\n",
        "-   `plt.imshow` does not accept x and y grids; set extent manually.\n",
        "-   The default origin for `imshow` is the upper left; set `origin='lower'` for consistency with contour plots.\n",
        "-   Adjust the aspect ratio with `plt.axis(aspect='image')` to ensure equal scaling.\n",
        "-   You can combine these functions for advanced visualizations.\n",
        "\n",
        "\n",
        "# Histograms, Binnings, and Density\n",
        "\n",
        "## What is a Histogram?\n",
        "\n",
        "-   A histogram is a graphical representation of the distribution of numerical data.\n",
        "-   It divides data into bins (intervals) and shows the frequency (count) of data points in each bin.\n",
        "-   Useful as a first step in understanding a dataset.\n",
        "\n",
        "\n",
        "## Creating a Simple Histogram\n"
      ],
      "id": "258e6155"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "%matplotlib inline\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "plt.style.use('seaborn-white')\n",
        "\n",
        "data = np.random.randn(1000)\n",
        "plt.hist(data)\n",
        "plt.show()"
      ],
      "id": "821fc415",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This displays the distribution of `data` in default bins\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Customizing Histograms\n",
        "\n",
        "The `hist()` function offers many options to control calculation and display:\n"
      ],
      "id": "dcd5396d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.hist(data, bins=30, normed=True, alpha=0.5,\n",
        "         histtype='stepfilled', color='steelblue',\n",
        "         edgecolor='none')\n",
        "plt.show()"
      ],
      "id": "a4f0ffb9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   `bins`: Number of bins\n",
        "-   `normed` (now `density`): Normalize the histogram so the area sums to 1\n",
        "-   `alpha`: Transparency\n",
        "-   `histtype`: Type of histogram (e.g., `'stepfilled'`)\n",
        "-   `color`, `edgecolor`: Color settings\\[2\\]\\[1\\]\n",
        "\n",
        "\n",
        "## Comparing Multiple Distributions\n",
        "\n",
        "Overlay several histograms using transparency for comparison:\n"
      ],
      "id": "ba2cc391"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "x1 = np.random.normal(0, 0.8, 1000)\n",
        "x2 = np.random.normal(-2, 1, 1000)\n",
        "x3 = np.random.normal(3, 2, 1000)\n",
        "\n",
        "kwargs = dict(histtype='stepfilled', alpha=0.3, normed=True, bins=40)\n",
        "plt.hist(x1, **kwargs)\n",
        "plt.hist(x2, **kwargs)\n",
        "plt.hist(x3, **kwargs)\n",
        "plt.show()"
      ],
      "id": "f0d48ed3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This helps to compare different data distributions on the same plot\\[2\\]\\[1\\].\n",
        "\n",
        "------------------------------------------------------------------------\n",
        "\n",
        "## Computing Histograms Without Plotting\n",
        "\n",
        "Use NumPy’s `np.histogram()` to get bin counts and edges:\n"
      ],
      "id": "4f282199"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "counts, bin_edges = np.histogram(data, bins=5)\n",
        "print(counts)"
      ],
      "id": "3a39659b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Output: `[ 12 190 468 301 29]` (example)\n",
        "\n",
        "------------------------------------------------------------------------\n",
        "\n",
        "## Two-Dimensional Histograms\n",
        "\n",
        "Visualize joint distributions by binning data in two dimensions.\n"
      ],
      "id": "cfe4bbbd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "mean = [0, 0]\n",
        "cov = [[1, 1], [1, 2]]\n",
        "x, y = np.random.multivariate_normal(mean, cov, 10000).T\n",
        "\n",
        "plt.hist2d(x, y, bins=30, cmap='Blues')\n",
        "cb = plt.colorbar()\n",
        "cb.set_label('counts in bin')\n",
        "plt.show()"
      ],
      "id": "2234840e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Two-Dimensional Histograms\n",
        "\n",
        "-   `plt.hist2d` creates a 2D histogram; `plt.colorbar` adds a color scale\\[2\\]\\[1\\].\n",
        "\n",
        "-   To compute the 2D histogram without plotting:\n"
      ],
      "id": "0aa59f46"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "counts, xedges, yedges = np.histogram2d(x, y, bins=30)"
      ],
      "id": "15f522e4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "For higher dimensions, use `np.histogramdd`.\n",
        "\n",
        "\n",
        "## Hexagonal Binning\n",
        "\n",
        "Use hexagons instead of squares for 2D binning:\n"
      ],
      "id": "1555db1c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.hexbin(x, y, gridsize=30, cmap='Blues')\n",
        "cb = plt.colorbar(label='count in bin')\n",
        "plt.show()"
      ],
      "id": "620f70f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`plt.hexbin` can also use weights and different aggregation functions\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Kernel Density Estimation (KDE)\n",
        "\n",
        "-   KDE provides a smooth estimate of the data’s probability density.\n",
        "-   Example using `scipy.stats.gaussian_kde`:\n"
      ],
      "id": "d7b3f02c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from scipy.stats import gaussian_kde\n",
        "\n",
        "data = np.vstack([x, y])\n",
        "kde = gaussian_kde(data)\n",
        "xgrid = np.linspace(-3.5, 3.5, 40)\n",
        "ygrid = np.linspace(-6, 6, 40)\n",
        "Xgrid, Ygrid = np.meshgrid(xgrid, ygrid)\n",
        "Z = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()]))\n",
        "\n",
        "plt.imshow(Z.reshape(Xgrid.shape),\n",
        "           origin='lower', aspect='auto',\n",
        "           extent=[-3.5, 3.5, -6, 6],\n",
        "           cmap='Blues')\n",
        "cb = plt.colorbar()\n",
        "cb.set_label(\"density\")\n",
        "plt.show()"
      ],
      "id": "bf996f66",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "KDE smooths the data, providing a continuous density estimate\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Summary Table: Histogram and Binning Functions\n",
        "\n",
        "| Function                   | Description                                |\n",
        "|----------------------------|--------------------------------------------|\n",
        "| `plt.hist`                 | 1D histogram plot                          |\n",
        "| `np.histogram`             | Compute 1D histogram counts and bins       |\n",
        "| `plt.hist2d`               | 2D histogram plot                          |\n",
        "| `np.histogram2d`           | Compute 2D histogram counts and bins       |\n",
        "| `plt.hexbin`               | 2D hexagonal bin plot                      |\n",
        "| `np.histogramdd`           | Multidimensional histogram counts and bins |\n",
        "| `scipy.stats.gaussian_kde` | Kernel density estimation                  |\n",
        "\n",
        "# Customizing Plot Legends in Matplotlib\n",
        "\n",
        "\n",
        "## Creating a Simple Legend\n",
        "\n",
        "-   Legends assign meaning to plot elements, making visualizations clearer and more informative.\n",
        "-   The simplest way to add a legend is with `plt.legend()` or `ax.legend()`.\n",
        "-   Any plot element with a `label` will appear in the legend.\n"
      ],
      "id": "f7adcbd1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "x = np.linspace(0, 10, 1000)\n",
        "fig, ax = plt.subplots()\n",
        "ax.plot(x, np.sin(x), '-b', label='Sine')\n",
        "ax.plot(x, np.cos(x), '--r', label='Cosine')\n",
        "ax.axis('equal')\n",
        "ax.legend()"
      ],
      "id": "142f101f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   By default, all labeled elements are included in the legend\n",
        "\n",
        "\n",
        "## Customizing Legend Placement and Appearance\n",
        "\n",
        "-   **Location:** Control legend placement with the `loc` parameter (e.g., `'upper left'`, `'lower center'`).\n",
        "-   **Frame:** Remove the legend box with `frameon=False`.\n",
        "-   **Columns:** Use `ncol` to arrange legend entries in multiple columns.\n",
        "-   **Aesthetics:** Customize with options like `fancybox`, `shadow`, `framealpha`, and `borderpad`.\n"
      ],
      "id": "75b54aea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "ax.legend(loc='upper left', frameon=False)\n",
        "ax.legend(frameon=False, loc='lower center', ncol=2)\n",
        "ax.legend(fancybox=True, framealpha=1, shadow=True, borderpad=1)"
      ],
      "id": "144689e8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   For more options, see the `plt.legend` docstring\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Choosing Elements for the Legend\n",
        "\n",
        "-   By default, all labeled elements are included.\n",
        "-   To control which elements appear, pass specific plot objects and labels to `legend()`:\n"
      ],
      "id": "1b6d8a4e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "y = np.sin(x[:, np.newaxis] + np.pi * np.arange(0, 2, 0.5))\n",
        "lines = plt.plot(x, y)\n",
        "plt.legend(lines[:2], ['first', 'second'])"
      ],
      "id": "40c44f25",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Choosing Elements for the Legend\n",
        "\n",
        "-   Alternatively, only label the elements you want in the legend:\n"
      ],
      "id": "0ab6d6dc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.plot(x, y[:, 0], label='first')\n",
        "plt.plot(x, y[:, 1], label='second')\n",
        "plt.plot(x, y[:, 2:])\n",
        "plt.legend(framealpha=1, frameon=True)"
      ],
      "id": "b1c31c02",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Only elements with a `label` attribute are shown in the legend\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Legends for Point Size (Custom Legend Entries)\n",
        "\n",
        "-   Sometimes you need a legend for non-standard features, like marker size.\n",
        "-   Example: Show city areas by point size in a scatter plot.\n"
      ],
      "id": "08587bb1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "for area in [100, 300, 500]:\n",
        "    plt.scatter([], [], c='k', alpha=0.3, s=area, label=str(area) + ' km$^2$')\n",
        "plt.legend(scatterpoints=1, frameon=False, labelspacing=1, title='City Area')"
      ],
      "id": "ebdaa860",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   By plotting empty lists, you create custom legend entries, even if those objects aren’t on the plot\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Multiple Legends\n",
        "\n",
        "-   Matplotlib only allows one legend per axes by default.\n",
        "-   To add a second legend, create a new `Legend` artist and add it manually:\n"
      ],
      "id": "aee58d02"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from matplotlib.legend import Legend\n",
        "\n",
        "fig, ax = plt.subplots()\n",
        "lines = []\n",
        "styles = ['-', '--', '-.', ':']\n",
        "x = np.linspace(0, 10, 1000)\n",
        "for i in range(4):\n",
        "    lines += ax.plot(x, np.sin(x - i * np.pi / 2), styles[i], color='black')\n",
        "ax.axis('equal')\n",
        "\n",
        "ax.legend(lines[:2], ['line A', 'line B'], loc='upper right', frameon=False)\n",
        "leg = Legend(ax, lines[2:], ['line C', 'line D'], loc='lower right', frameon=False)\n",
        "ax.add_artist(leg)"
      ],
      "id": "24031bfd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   This approach lets you display multiple legends on a single plot\\[2\\]\\[1\\].\n",
        "\n",
        "------------------------------------------------------------------------\n",
        "\n",
        "## Key Points\n",
        "\n",
        "-   Use `label` in plotting commands and call `legend()` to create legends.\n",
        "-   Customize legends with location, columns, frame, and more.\n",
        "-   Control legend entries by labeling only desired elements or passing specific objects.\n",
        "-   For complex cases (e.g., marker size), add custom legend entries by plotting empty objects.\n",
        "-   For multiple legends, use the `Legend` artist and `ax.add_artist()`.\n",
        "\n",
        "# Customizing Colorbars in Matplotlib\n",
        "\n",
        "## Why Use Colorbars?\n",
        "\n",
        "-   Colorbars provide a key for interpreting the meaning of colors in plots, especially when representing continuous data values.\n",
        "-   While legends are for discrete labels, colorbars are essential for continuous labels (e.g., heatmaps, density plots)\\[2\\]\\[1\\].\n",
        "\n",
        "------------------------------------------------------------------------\n",
        "\n",
        "## Creating a Basic Colorbar\n",
        "\n",
        "-   The simplest way to add a colorbar is with `plt.colorbar()` after a plotting function that uses color mapping:\n"
      ],
      "id": "9ad87587"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "x = np.linspace(0, 10, 1000)\n",
        "I = np.sin(x) * np.cos(x[:, np.newaxis])\n",
        "\n",
        "plt.imshow(I)\n",
        "plt.colorbar()"
      ],
      "id": "a9429499",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   This displays the image and adds a colorbar indicating the mapping from data values to colors\n",
        "\n",
        "\n",
        "## Customizing Colormaps\n",
        "\n",
        "Specify a colormap with the `cmap` argument:\n"
      ],
      "id": "5174175a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.imshow(I, cmap='gray')"
      ],
      "id": "84346c33",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   All available colormaps are in the `plt.cm` namespace (e.g., `plt.cm.viridis`, `plt.cm.RdBu`).\n",
        "\n",
        "\n",
        "## Types of Colormaps\n",
        "\n",
        "-   **Sequential colormaps**: One continuous color sequence (e.g., `binary`, `viridis`).\n",
        "-   **Divergent colormaps**: Two contrasting colors for positive/negative deviations (e.g., `RdBu`, `PuOr`).\n",
        "-   **Qualitative colormaps**: No particular sequence, for categorical data (e.g., `rainbow`, `jet`).\n",
        "\n",
        "\n",
        "## Choosing the Right Colormap\n",
        "\n",
        "-   Prefer colormaps like `viridis` for continuous data, as they have even brightness and are perceptually uniform—even in grayscale.\n",
        "-   For rainbow-like schemes, consider `cubehelix`.\n",
        "-   For data with a meaningful center (e.g., deviations from zero), use divergent maps like `RdBu`, but be careful with grayscale reproduction\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Setting Color Limits and Extensions\n",
        "\n",
        "-   You can manually set color limits with `plt.clim()` and indicate out-of-bounds values using the `extend` property in the colorbar:\n"
      ],
      "id": "6c952459"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.imshow(I, cmap='RdBu')\n",
        "plt.colorbar(extend='both')\n",
        "plt.clim(-1, 1)"
      ],
      "id": "49ec59f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   This is useful when you want to focus on a specific data range and highlight values outside that range with arrows at the ends of the colorbar\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Discrete Colorbars\n",
        "\n",
        "-   To represent discrete values, use a colormap with a specified number of bins:\n"
      ],
      "id": "6df2de6f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.imshow(I, cmap=plt.cm.get_cmap('Blues', 6))\n",
        "plt.colorbar()\n",
        "plt.clim(-1, 1)"
      ],
      "id": "3af20410",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   This approach is useful for categorical or binned data\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Example: Visualizing Handwritten Digits\n",
        "\n",
        "-   Visualize digit images:\n"
      ],
      "id": "e06e02d7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from sklearn.datasets import load_digits\n",
        "digits = load_digits(n_class=6)\n",
        "fig, ax = plt.subplots(8, 8, figsize=(6, 6))\n",
        "for i, axi in enumerate(ax.flat):\n",
        "    axi.imshow(digits.images[i], cmap='binary')\n",
        "    axi.set(xticks=[], yticks=[])"
      ],
      "id": "659b0585",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Example: Visualizing Handwritten Digits\n",
        "\n",
        "-   Use dimensionality reduction and a discrete colorbar for class labels:\n"
      ],
      "id": "2d0dcffe"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from sklearn.manifold import Isomap\n",
        "iso = Isomap(n_components=2)\n",
        "projection = iso.fit_transform(digits.data)\n",
        "\n",
        "plt.scatter(projection[:, 0], projection[:, 1], lw=0.1,\n",
        "            c=digits.target, cmap=plt.cm.get_cmap('cubehelix', 6))\n",
        "plt.colorbar(ticks=range(6), label='digit value')\n",
        "plt.clim(-0.5, 5.5)"
      ],
      "id": "fe4cc819",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Here, the colorbar clearly distinguishes digit classes\\[2\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Key Points\n",
        "\n",
        "-   Use colorbars for continuous data and choose colormaps thoughtfully for clarity and accessibility.\n",
        "-   Customize colorbars with colormap selection, color limits, extensions, and discrete bins.\n",
        "-   Always consider how your color choices will appear in grayscale or to colorblind viewers\\[2\\]\\[1\\].\n",
        "\n",
        "# Multiple Subplots in Matplotlib\n",
        "\n",
        "\n",
        "## Why Use Multiple Subplots?\n",
        "\n",
        "-   Comparing data side by side is often helpful for analysis and presentation.\n",
        "-   Matplotlib allows you to arrange multiple smaller plots (subplots) within a single figure.\n",
        "\n",
        "Four Ways to Create Subplots\n",
        "\n",
        "## 1. **Manual Placement with `plt.axes` and `fig.add_axes`**\n",
        "\n",
        "-   Create axes anywhere in the figure by specifying `[left, bottom, width, height]` in figure coordinates (0 to 1).\n"
      ],
      "id": "b91c6137"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "ax1 = plt.axes()  # Standard axes\n",
        "ax2 = plt.axes([0.65, 0.65, 0.2, 0.2])  # Inset axes at top-right"
      ],
      "id": "3aa513da",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 1. **Manual Placement with `plt.axes` and `fig.add_axes`**\n",
        "\n",
        "-   With the object-oriented interface:\n"
      ],
      "id": "d53d5aec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig = plt.figure()\n",
        "ax1 = fig.add_axes([0.1, 0.5, 0.8, 0.4], xticklabels=[], ylim=(-1.2, 1.2))\n",
        "ax2 = fig.add_axes([0.1, 0.1, 0.8, 0.4], ylim=(-1.2, 1.2))\n",
        "x = np.linspace(0, 10)\n",
        "ax1.plot(np.sin(x))\n",
        "ax2.plot(np.cos(x))"
      ],
      "id": "22deaac1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. **Simple Grids with `plt.subplot` and `fig.add_subplot`**\n",
        "\n",
        "-   Create a grid of subplots by specifying rows, columns, and plot index (starts at 1, goes left-to-right, top-to-bottom).\n"
      ],
      "id": "12c8a42b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "for i in range(1, 7):\n",
        "    plt.subplot(2, 3, i)\n",
        "    plt.text(0.5, 0.5, str((2, 3, i)), fontsize=18, ha='center')"
      ],
      "id": "6e15c56d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. **Simple Grids with `plt.subplot` and `fig.add_subplot`**\n",
        "-   Adjust spacing between subplots:\n"
      ],
      "id": "b421cf73"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig = plt.figure()\n",
        "fig.subplots_adjust(hspace=0.4, wspace=0.4)\n",
        "for i in range(1, 7):\n",
        "    ax = fig.add_subplot(2, 3, i)\n",
        "    ax.text(0.5, 0.5, str((2, 3, i)), fontsize=18, ha='center')"
      ],
      "id": "62cefdcb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   `hspace` and `wspace` control the height and width between subplots (as a fraction of subplot size).\n",
        "\n",
        "\n",
        "## 3. **Full Grid with `plt.subplots`**\n",
        "\n",
        "-   Quickly create a grid of subplots and get them as a NumPy array for easy access.\n"
      ],
      "id": "d948d97e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig, ax = plt.subplots(2, 3, sharex='col', sharey='row')\n",
        "for i in range(2):\n",
        "    for j in range(3):\n",
        "        ax[i, j].text(0.5, 0.5, str((i, j)), fontsize=18, ha='center')\n",
        "fig"
      ],
      "id": "65ee1e1f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   `sharex` and `sharey` allow axes to share x or y axis labels/scales.\n",
        "-   Axes are accessed with standard array indexing: `ax[row, col]`.\n",
        "\n",
        "\n",
        "## 4. **Flexible Layouts with `plt.GridSpec`**\n",
        "\n",
        "-   For more complex arrangements (e.g., subplots spanning multiple rows/columns).\n"
      ],
      "id": "8bbbba24"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "grid = plt.GridSpec(2, 3, wspace=0.4, hspace=0.3)\n",
        "plt.subplot(grid[0, 0])\n",
        "plt.subplot(grid[0, 1:])\n",
        "plt.subplot(grid[1, :2])\n",
        "plt.subplot(grid[1, 2])"
      ],
      "id": "437c4b27",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 4. **Flexible Layouts with `plt.GridSpec`**\n",
        "-   Use slicing to specify subplot positions and extents.\n",
        "\n",
        "-   Example: Scatter plot with marginal histograms\n"
      ],
      "id": "95d0f601"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "mean = [0, 0]\n",
        "cov = [[1, 1], [1, 2]]\n",
        "x, y = np.random.multivariate_normal(mean, cov, 3000).T\n",
        "\n",
        "fig = plt.figure(figsize=(6, 6))\n",
        "grid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)\n",
        "main_ax = fig.add_subplot(grid[:-1, 1:])\n",
        "y_hist = fig.add_subplot(grid[:-1, 0], xticklabels=[], sharey=main_ax)\n",
        "x_hist = fig.add_subplot(grid[-1, 1:], yticklabels=[], sharex=main_ax)\n",
        "\n",
        "main_ax.plot(x, y, 'ok', markersize=3, alpha=0.2)\n",
        "x_hist.hist(x, 40, histtype='stepfilled', orientation='vertical', color='gray')\n",
        "x_hist.invert_yaxis()\n",
        "y_hist.hist(y, 40, histtype='stepfilled', orientation='horizontal', color='gray')\n",
        "y_hist.invert_xaxis()"
      ],
      "id": "b21988d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Summary Table\n",
        "\n",
        "| Method         | Use Case                               | Access Pattern    |\n",
        "|--------------------|----------------------------------|-------------------|\n",
        "| `plt.axes`     | Manual, precise placement              | Variable names    |\n",
        "| `plt.subplot`  | Simple grid, small number of subplots  | Index (1-based)   |\n",
        "| `plt.subplots` | Full grid, easy access, larger layouts | Array indexing    |\n",
        "| `plt.GridSpec` | Complex, flexible layouts              | Slicing, subplots |\n",
        "\n",
        "------------------------------------------------------------------------\n",
        "\n",
        "## Tips\n",
        "\n",
        "-   Use `plt.subplots()` for most grid layouts—it's concise and Pythonic.\n",
        "-   Use `plt.GridSpec` for advanced arrangements (e.g., subplots spanning multiple rows/columns).\n",
        "-   Adjust subplot spacing with `plt.subplots_adjust()` or `GridSpec` parameters.\n",
        "-   Sharing axes (`sharex`, `sharey`) makes multi-panel plots cleaner.\n",
        "\n",
        "# Text and Annotation in Matplotlib\n",
        "\n",
        "\n",
        "## Why Use Text and Annotations?\n",
        "\n",
        "-   Text and annotations help guide the viewer and highlight important features in your visualizations.\n",
        "-   They can clarify, label, or call attention to specific data points or trends, making your plots more informative and easier to interpret\\[12\\]\\[1\\].\n",
        "\n",
        "## Adding Basic Text with `ax.text`\n",
        "\n",
        "-   The `ax.text()` method places text at a specified position on the plot.\n",
        "-   Syntax: `ax.text(x, y, s, **kwargs)`\n",
        "    -   `x`, `y`: Coordinates for the text position.\n",
        "    -   `s`: The string to display.\n",
        "    -   Additional keyword arguments control appearance (size, color, alignment, etc.).\n",
        "\n",
        "## Adding Basic Text with `ax.text`\n"
      ],
      "id": "303001d0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig, ax = plt.subplots(figsize=(12, 4))\n",
        "births_by_date.plot(ax=ax)\n",
        "style = dict(size=10, color='gray')\n",
        "ax.text('2012-1-1', 3950, \"New Year's Day\", **style)\n",
        "ax.text('2012-7-4', 4250, \"Independence Day\", ha='center', **style)\n",
        "ax.text('2012-9-4', 4850, \"Labor Day\", ha='center', **style)\n",
        "ax.text('2012-10-31', 4600, \"Halloween\", ha='right', **style)\n",
        "ax.text('2012-11-25', 4450, \"Thanksgiving\", ha='center', **style)\n",
        "ax.text('2012-12-25', 3850, \"Christmas\", ha='right', **style)"
      ],
      "id": "12c4cf7d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   `ha` stands for *horizontal alignment* and can be `'left'`, `'center'`, or `'right'`\n",
        "\n",
        "## Coordinate Systems and Transforms\n",
        "\n",
        "-   By default, text is placed using data coordinates.\n",
        "-   You can also use axes or figure-relative coordinates for fixed positioning, regardless of data scaling:\n",
        "    -   `ax.transData`: Data coordinates (default).\n",
        "    -   `ax.transAxes`: Axes coordinates (0,0 bottom-left; 1,1 top-right of axes).\n",
        "    -   `fig.transFigure`: Figure coordinates (0,0 bottom-left; 1,1 top-right of figure).\n",
        "\n",
        "## Coordinate Systems and Transforms\n"
      ],
      "id": "8a79bb1a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig, ax = plt.subplots(facecolor='lightgray')\n",
        "ax.axis([0, 10, 0, 10])\n",
        "ax.text(1, 5, \". Data: (1, 5)\", transform=ax.transData)\n",
        "ax.text(0.5, 0.1, \". Axes: (0.5, 0.1)\", transform=ax.transAxes)\n",
        "ax.text(0.2, 0.2, \". Figure: (0.2, 0.2)\", transform=fig.transFigure)"
      ],
      "id": "9ac19076",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Changing axis limits only affects text placed in data coordinates\\[12\\]\\[1\\].\n",
        "\n",
        "\n",
        "## Annotating with Arrows: `ax.annotate`\n",
        "\n",
        "-   Use `ax.annotate()` to add text with optional arrows pointing to data points.\n",
        "-   This is more flexible and robust than `plt.arrow()` for most annotation needs.\n",
        "\n",
        "**Syntax:**\n"
      ],
      "id": "75bf39e6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "ax.annotate(text, xy, xytext=None, xycoords='data', textcoords=None, arrowprops=None, **kwargs)"
      ],
      "id": "26632bde",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Annotating with Arrows: `ax.annotate`\n",
        "\n",
        "-   `text`: Annotation string.\n",
        "-   `xy`: Point to annotate (x, y).\n",
        "-   `xytext`: Position for the text (optional).\n",
        "-   `xycoords`, `textcoords`: Coordinate systems for `xy` and `xytext`.\n",
        "-   `arrowprops`: Dictionary of arrow style properties\\[12\\]\\[1\\].\n",
        "\n",
        "## Annotating with Arrows: `ax.annotate`\n"
      ],
      "id": "2e94ea4a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig, ax = plt.subplots()\n",
        "x = np.linspace(0, 20, 1000)\n",
        "ax.plot(x, np.cos(x))\n",
        "ax.axis('equal')\n",
        "ax.annotate('local maximum', xy=(6.28, 1), xytext=(10, 4),\n",
        "            arrowprops=dict(facecolor='black', shrink=0.05))\n",
        "ax.annotate('local minimum', xy=(5 * np.pi, -1), xytext=(2, -6),\n",
        "            arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"angle3,angleA=0,angleB=-90\"))"
      ],
      "id": "086baa57",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Advanced Annotation Options\n",
        "\n",
        "-   `arrowprops` can control arrow style, color, width, connection style, and more.\n",
        "-   `bbox` can add a box around the annotation text for emphasis.\n",
        "\n",
        "**Example with custom arrows and boxes:**\n"
      ],
      "id": "29326c2b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "ax.annotate(\"Independence Day\", xy=('2012-7-4', 4250), xycoords='data',\n",
        "            bbox=dict(boxstyle=\"round\", fc=\"none\", ec=\"gray\"),\n",
        "            xytext=(10, -40), textcoords='offset points', ha='center',\n",
        "            arrowprops=dict(arrowstyle=\"->\"))"
      ],
      "id": "7d96c7df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Use `arrowstyle`, `connectionstyle`, and other parameters to create a wide range of annotation effects.\n",
        "\n",
        "\n",
        "## Summary Table: Key Annotation Methods\n",
        "\n",
        "| Method        | Use Case                           |\n",
        "|---------------|------------------------------------|\n",
        "| `ax.text`     | Place simple text at (x, y)        |\n",
        "| `ax.annotate` | Annotate a point with text & arrow |\n",
        "\n",
        "\n",
        "## Tips\n",
        "\n",
        "-   Use `ax.text` for simple labels and `ax.annotate` for arrows and advanced annotations.\n",
        "-   Use coordinate transforms for fixed positioning relative to axes or figure.\n",
        "-   Explore `arrowprops` and `bbox` for advanced visual styling.\n",
        "\n",
        "\n",
        "\n",
        "# Configurations and Stylesheets\n",
        "\n",
        "\n",
        "## Why Customize Matplotlib?\n",
        "\n",
        "-   The default Matplotlib styles are functional, but often not visually appealing or suitable for all purposes.\n",
        "-   Customizing styles allows you to create more attractive, readable, or publication-ready plots that match your preferences or requirements\n",
        "\n",
        "\n",
        "## Changing Defaults with `rcParams`\n",
        "\n",
        "-   Matplotlib maintains a runtime configuration (rc) dictionary called `rcParams` that controls the default styles for all plot elements.\n",
        "-   You can modify these settings globally during a session using `plt.rc` or by updating `plt.rcParams` directly.\n",
        "\n",
        "## Changing Defaults with `rcParams`\n"
      ],
      "id": "f3449a1e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "from matplotlib import cycler\n",
        "\n",
        "# Save current settings\n",
        "IPython_default = plt.rcParams.copy()\n",
        "\n",
        "# Change some rc parameters\n",
        "colors = cycler('color', ['#EE6666', '#3388BB', '#9988DD', '#EECC55', '#88BB44', '#FFBBBB'])\n",
        "plt.rc('axes', facecolor='#E6E6E6', edgecolor='none', axisbelow=True, grid=True, prop_cycle=colors)\n",
        "plt.rc('grid', color='w', linestyle='solid')\n",
        "plt.rc('xtick', direction='out', color='gray')\n",
        "plt.rc('ytick', direction='out', color='gray')\n",
        "plt.rc('patch', edgecolor='#E6E6E6')\n",
        "plt.rc('lines', linewidth=2)"
      ],
      "id": "a42b40bc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Changing Defaults with `rcParams`\n",
        "\n",
        "-   These settings affect all subsequent plots in the session.\n",
        "-   To reset to defaults, use:\n"
      ],
      "id": "a60ae176"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.rcParams.update(IPython_default)"
      ],
      "id": "0f1f5509",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Stylesheets: Fast and Convenient Customization\n",
        "\n",
        "-   Since Matplotlib 1.4, the `style` module allows you to quickly apply a set of predefined or custom styles.\n",
        "-   Stylesheets are `.mplstyle` files, similar to `.matplotlibrc` files, but easier to use and share\n",
        "\n",
        "**List Available Styles:**\n"
      ],
      "id": "f3494c84"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "print(plt.style.available[:5])\n",
        "# Example output: ['fivethirtyeight', 'seaborn-pastel', 'seaborn-whitegrid', 'ggplot', 'grayscale']"
      ],
      "id": "39514617",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Apply a Style Globally:**\n"
      ],
      "id": "bcff9be1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.style.use('ggplot')"
      ],
      "id": "92d95415",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Apply a Style Temporarily:**\n"
      ],
      "id": "01b1a26c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "with plt.style.context('fivethirtyeight'):\n",
        "    # Your plotting code here\n",
        "    plt.plot([1, 2, 3], [4, 5, 6])"
      ],
      "id": "1e6ab068",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   The context manager ensures the style only applies within the `with` block.\n",
        "\n",
        "\n",
        "## Popular Built-in Styles\n",
        "\n",
        "-   **fivethirtyeight**: Bold colors, thick lines, transparent axes.\n",
        "-   **ggplot**: Mimics R's ggplot2 default style.\n",
        "-   **bmh**: Inspired by \"Bayesian Methods for Hackers\" book.\n",
        "-   **dark_background**: For presentations or dark themes.\n",
        "-   **grayscale**: For black-and-white or print publications.\n",
        "-   **seaborn-\\***: Styles inspired by the Seaborn library.\n"
      ],
      "id": "ed6b6d6f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "with plt.style.context('dark_background'):\n",
        "    plt.plot([1, 2, 3], [1, 4, 9])"
      ],
      "id": "7ee45c79",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Creating and Using Custom Stylesheets\n",
        "\n",
        "-   You can create your own `.mplstyle` file to define custom styles.\n",
        "-   Place your file in a known directory and load it with:\n"
      ],
      "id": "70f87b04"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.style.use('/path/to/yourstyle.mplstyle')"
      ],
      "id": "8f24b94f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Or combine multiple styles:\n"
      ],
      "id": "f91c31e5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.style.use(['dark_background', '/path/to/presentation.mplstyle'])"
      ],
      "id": "6da0716f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Later styles in the list override earlier ones if they set the same properties\n",
        "\n",
        "\n",
        "## Summary Table: Customization Methods\n",
        "\n",
        "| Method | Scope | Example |\n",
        "|-----------------------|------------------|-------------------------------|\n",
        "| `plt.rc` / `plt.rcParams` | Global (session) | `plt.rc('lines', linewidth=2)` |\n",
        "| `.matplotlibrc` file | Global (user/system) | Edit `~/.config/matplotlib/matplotlibrc` |\n",
        "| Stylesheet (`.mplstyle`) | Global or temporary | `plt.style.use('ggplot')` |\n",
        "| Style context manager | Temporary (block) | `with plt.style.context('bmh'):` |\n",
        "\n",
        "\n",
        "## Key Takeaways\n",
        "\n",
        "-   Use `rcParams` for fine-grained, session-wide control.\n",
        "-   Use stylesheets for quick, consistent, and shareable visual themes.\n",
        "-   Combine or create your own styles for maximum flexibility.\n",
        "-   Use the style context manager to limit style changes to specific plots or code blocks.\n",
        "\n",
        "# Geographic Data Visualization with Basemap\n",
        "\n",
        "## Introduction to Basemap\n",
        "\n",
        "-   **Basemap** is a toolkit for Matplotlib that enables the visualization of geographic (map-based) data in Python.\n",
        "-   It allows you to plot data points, lines, and shapes onto a variety of map projections, adding geographic context to your visualizations.\n",
        "-   While Basemap is somewhat dated and can be slow for complex maps, it remains a powerful tool for many geographic visualization tasks in Python\n",
        "\n",
        "## Installing and Importing Basemap\n",
        "\n",
        "-   Basemap is not included with standard Matplotlib and must be installed separately (e.g., via `conda install basemap`).\n",
        "-   Basic imports for a Basemap workflow:\n"
      ],
      "id": "f915851f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "%matplotlib inline\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from mpl_toolkits.basemap import Basemap"
      ],
      "id": "bb1cc16c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   For some backgrounds, you may also need the `pillow` package (for image handling)\n",
        "\n",
        "\n",
        "## Creating Your First Map\n",
        "\n",
        "-   Basemap provides a variety of map projections. Here’s a simple example using the orthographic projection:\n"
      ],
      "id": "1d65aedf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "plt.figure(figsize=(8, 8))\n",
        "m = Basemap(projection='ortho', resolution=None, lat_0=50, lon_0=-100)\n",
        "m.bluemarble(scale=0.5)\n",
        "plt.show()"
      ],
      "id": "adf7a128",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   The map is not just an image, but a Matplotlib axes that understands spherical coordinates, allowing you to plot data directly on top\\[1\\]\\[12\\].\n",
        "\n",
        "\n",
        "## Map Projections\n",
        "\n",
        "-   Basemap supports dozens of map projections, each suited for different use cases and regions.\n",
        "-   Common projections include:\n",
        "    -   **Cylindrical** (`'cyl'`, `'merc'`, `'cea'`)\n",
        "    -   **Pseudo-cylindrical** (`'moll'`, `'sinu'`, `'robin'`)\n",
        "    -   **Perspective** (`'ortho'`, `'gnom'`, `'stere'`)\n",
        "    -   **Conic** (`'lcc'`, `'eqdc'`, `'aea'`)\n",
        "-   Example: Cylindrical projection\n"
      ],
      "id": "b57fdc85"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig = plt.figure(figsize=(8, 6))\n",
        "m = Basemap(projection='cyl', resolution=None,\n",
        "            llcrnrlat=-90, urcrnrlat=90,\n",
        "            llcrnrlon=-180, urcrnrlon=180)\n",
        "m.drawcoastlines()\n",
        "plt.show()"
      ],
      "id": "1176de58",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Each projection requires specific parameters (e.g., center latitude/longitude, width/height)\n",
        "\n",
        "## Drawing Map Features\n",
        "\n",
        "-   Basemap provides methods to add physical and political features:\n",
        "\n",
        "| Method              | Description                       |\n",
        "|---------------------|-----------------------------------|\n",
        "| `drawcoastlines()`  | Draws continental coastlines      |\n",
        "| `drawcountries()`   | Draws country boundaries          |\n",
        "| `drawstates()`      | Draws US state boundaries         |\n",
        "| `drawrivers()`      | Draws rivers                      |\n",
        "| `fillcontinents()`  | Fills continents with color       |\n",
        "| `drawmapboundary()` | Draws/fills map boundary          |\n",
        "| `drawparallels()`   | Draws lines of constant latitude  |\n",
        "| `drawmeridians()`   | Draws lines of constant longitude |\n",
        "| `shadedrelief()`    | Shaded relief background          |\n",
        "| `bluemarble()`      | NASA Blue Marble image            |\n",
        "| `etopo()`           | Topographic relief                |\n",
        "\n",
        "## Drawing Map Features\n",
        "-   Example: Adding features and plotting a city\n"
      ],
      "id": "01c29b9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "fig = plt.figure(figsize=(8, 8))\n",
        "m = Basemap(projection='lcc', resolution=None, width=8E6, height=8E6, lat_0=45, lon_0=-100)\n",
        "m.etopo(scale=0.5, alpha=0.5)\n",
        "x, y = m(-122.3, 47.6)  # Seattle coordinates\n",
        "plt.plot(x, y, 'ok', markersize=5)\n",
        "plt.text(x, y, ' Seattle', fontsize=12)\n",
        "plt.show()"
      ],
      "id": "9641c339",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Plotting Data on Maps\n",
        "\n",
        "-   Basemap allows you to overlay your own data (points, lines, images, etc.) using its coordinate transformation capabilities.\n",
        "-   To plot geographic data, convert latitude and longitude to map coordinates using the Basemap instance:\n"
      ],
      "id": "61eb64ae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "x, y = m(lon, lat)\n",
        "plt.plot(x, y, 'o')"
      ],
      "id": "c33233d2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Many plotting methods (e.g., `scatter`, `plot`, `contour`, `pcolormesh`) support a `latlon=True` argument for direct use of lat/lon data\\[1\\].\n",
        "\n",
        "\n",
        "## Example: California Cities\n",
        "\n",
        "-   Visualize city locations, population, and area on a map:\n"
      ],
      "id": "d922fe3b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import pandas as pd\n",
        "\n",
        "cities = pd.read_csv('data/california_cities.csv')\n",
        "lat = cities['latd'].values\n",
        "lon = cities['longd'].values\n",
        "population = cities['population_total'].values\n",
        "area = cities['area_total_km2'].values\n",
        "\n",
        "fig = plt.figure(figsize=(8, 8))\n",
        "m = Basemap(projection='lcc', resolution='h',\n",
        "            lat_0=37.5, lon_0=-119, width=1E6, height=1.2E6)\n",
        "m.shadedrelief()\n",
        "m.drawcoastlines(color='gray')\n",
        "m.drawcountries(color='gray')\n",
        "m.drawstates(color='gray')\n",
        "\n",
        "m.scatter(lon, lat, latlon=True, c=np.log10(population), s=area,\n",
        "          cmap='Reds', alpha=0.5)\n",
        "plt.colorbar(label=r'$\\log_{10}({\\rm population})$')\n",
        "plt.clim(3, 7)\n",
        "\n",
        "# Dummy points for area legend\n",
        "for a in [100, 300, 500]:\n",
        "    plt.scatter([], [], c='k', alpha=0.5, s=a, label=str(a) + ' km$^2$')\n",
        "plt.legend(scatterpoints=1, frameon=False, labelspacing=1, loc='lower left')\n",
        "plt.show()"
      ],
      "id": "20d4387c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   This map shows population (color) and area (size) of cities, with geographic context\n",
        "\n",
        "\n",
        "## Example: Visualizing Climate Data\n",
        "\n",
        "-   Basemap can plot gridded or continuous data (e.g., temperature anomalies):\n"
      ],
      "id": "700f8624"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "from netCDF4 import Dataset, date2index\n",
        "from datetime import datetime\n",
        "\n",
        "data = Dataset('gistemp250.nc')\n",
        "lat = data.variables['lat'][:]\n",
        "lon = data.variables['lon'][:]\n",
        "lon, lat = np.meshgrid(lon, lat)\n",
        "timeindex = date2index(datetime(2014, 1, 15), data.variables['time'])\n",
        "temp_anomaly = data.variables['tempanomaly'][timeindex]\n",
        "\n",
        "fig = plt.figure(figsize=(10, 8))\n",
        "m = Basemap(projection='lcc', resolution='c', width=8E6, height=8E6, lat_0=45, lon_0=-100)\n",
        "m.shadedrelief(scale=0.5)\n",
        "m.pcolormesh(lon, lat, temp_anomaly, latlon=True, cmap='RdBu_r')\n",
        "plt.clim(-8, 8)\n",
        "m.drawcoastlines(color='lightgray')\n",
        "plt.title('January 2014 Temperature Anomaly')\n",
        "plt.colorbar(label='temperature anomaly (°C)')\n",
        "plt.show()"
      ],
      "id": "7c4360f3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This example uses a divergent colormap to show positive and negative temperature anomalies\n",
        "\n",
        "\n",
        "## Tips and Best Practices\n",
        "\n",
        "-   **Choose the right projection** for your region and data type.\n",
        "-   **Set the resolution** parameter appropriately: `'c'` (crude), `'l'` (low), `'i'` (intermediate), `'h'` (high), `'f'` (full), or `None` for no boundaries. Higher resolutions are slower but more detailed.\n",
        "-   **Overlay data** using standard Matplotlib plotting functions after transforming coordinates.\n",
        "-   **Use map features** (coastlines, boundaries, relief backgrounds) to provide context.\n",
        "-   **Legends and colorbars** are essential for interpreting size, color, and other encodings on your map\n",
        "\n",
        "## Summary\n",
        "\n",
        "-   Basemap extends Matplotlib for geographic visualization, supporting many projections and map features.\n",
        "-   You can plot points, lines, images, and continuous data on maps, with full control over projection, resolution, and appearance.\n",
        "-   While Basemap is powerful, consider newer libraries (like Cartopy or GeoPandas) for modern projects, but Basemap remains a valuable tool for many applications\\[1\\]\\[12\\].\n",
        "\n",
        "# Visualization with Seaborn\n",
        "\n",
        "## Why Use Seaborn?\n",
        "\n",
        "-   **Seaborn** is a high-level Python data visualization library built on top of Matplotlib.\n",
        "-   It addresses several Matplotlib limitations:\n",
        "    -   More attractive and modern default styles.\n",
        "    -   High-level commands for common statistical plots.\n",
        "    -   Direct integration with Pandas DataFrames, using column names for labels and grouping.\n",
        "-   Seaborn makes statistical visualization easier, more concise, and more visually appealing\n",
        "\n",
        "\n",
        "## Seaborn vs. Matplotlib: A Simple Example\n",
        "\n",
        "-   Matplotlib requires more setup for attractive plots:\n"
      ],
      "id": "128f402c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import matplotlib.pyplot as plt\n",
        "plt.style.use('classic')\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "\n",
        "rng = np.random.RandomState(0)\n",
        "x = np.linspace(0, 10, 500)\n",
        "y = np.cumsum(rng.randn(500, 6), 0)\n",
        "\n",
        "plt.plot(x, y)\n",
        "plt.legend('ABCDEF', ncol=2, loc='upper left');"
      ],
      "id": "506bb547",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   With Seaborn, you can improve style and aesthetics instantly:\n"
      ],
      "id": "3863d4d4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import seaborn as sns\n",
        "sns.set()\n",
        "\n",
        "plt.plot(x, y)\n",
        "plt.legend('ABCDEF', ncol=2, loc='upper left');"
      ],
      "id": "75f60069",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## High-Level Statistical Plotting with Seaborn\n",
        "\n",
        "Seaborn provides concise, powerful functions for a variety of statistical visualizations:\n",
        "\n",
        "## 1. **Histograms and KDEs**\n"
      ],
      "id": "8fb48822"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "import pandas as pd\n",
        "data = np.random.multivariate_normal([0, 0], [[5, 2], [2, 2]], size=2000)\n",
        "data = pd.DataFrame(data, columns=['x', 'y'])\n",
        "\n",
        "import seaborn as sns\n",
        "for col in 'xy':\n",
        "    sns.kdeplot(data[col], shade=True)\n",
        "sns.distplot(data['x'])\n",
        "sns.distplot(data['y'])"
      ],
      "id": "33a834d2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   For 2D distributions:\n"
      ],
      "id": "487deb03"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sns.kdeplot(data)"
      ],
      "id": "2eedf3c1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. **Joint and Pair Plots**\n",
        "\n",
        "-   **Jointplot**: Shows joint and marginal distributions.\n"
      ],
      "id": "eb7f284e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "with sns.axes_style('white'):\n",
        "    sns.jointplot(\"x\", \"y\", data, kind='kde')\n",
        "    sns.jointplot(\"x\", \"y\", data, kind='hex')"
      ],
      "id": "256df806",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Pairplot**: Plots all pairs of variables in a dataset.\n"
      ],
      "id": "ed6155aa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "iris = sns.load_dataset(\"iris\")\n",
        "sns.pairplot(iris, hue='species', size=2.5)"
      ],
      "id": "61578081",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 3. **Faceted Histograms and Factor Plots**\n",
        "\n",
        "-   **FacetGrid**: Easily create grids of histograms or other plots for subsets of data.\n"
      ],
      "id": "1af8b928"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "tips = sns.load_dataset('tips')\n",
        "tips['tip_pct'] = 100 * tips['tip'] / tips['total_bill']\n",
        "grid = sns.FacetGrid(tips, row=\"sex\", col=\"time\", margin_titles=True)\n",
        "grid.map(plt.hist, \"tip_pct\", bins=np.linspace(0, 40, 15))"
      ],
      "id": "afcb7a79",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Factorplot**: Visualize distributions across categories.\n"
      ],
      "id": "8da3b7f7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "with sns.axes_style(style='ticks'):\n",
        "    g = sns.factorplot(\"day\", \"total_bill\", \"sex\", data=tips, kind=\"box\")\n",
        "    g.set_axis_labels(\"Day\", \"Total Bill\")"
      ],
      "id": "cb7623d9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 4. **Violin, Regression, and Bar Plots**\n",
        "\n",
        "-   **Violin Plot**: Compare distributions between groups.\n"
      ],
      "id": "34d2661f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "sns.violinplot(\"gender\", \"split_frac\", data=data, palette=[\"lightblue\", \"lightpink\"])"
      ],
      "id": "a3996f65",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Regression Plot**: Show linear relationships with confidence intervals.\n"
      ],
      "id": "94dd758e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "g = sns.lmplot('final_sec', 'split_frac', col='gender', data=data,\n",
        "               markers=\".\", scatter_kws=dict(color='c'))\n",
        "g.map(plt.axhline, y=0.1, color=\"k\", ls=\":\")"
      ],
      "id": "a01895af",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Bar Plot**: Show counts or summary statistics by category.\n"
      ],
      "id": "3ed1e2b5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "planets = sns.load_dataset('planets')\n",
        "with sns.axes_style('white'):\n",
        "    g = sns.factorplot(\"year\", data=planets, aspect=2, kind=\"count\", color='steelblue')\n",
        "    g.set_xticklabels(step=5)"
      ],
      "id": "9c4fcb52",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Key Features of Seaborn\n",
        "\n",
        "-   **High-level interface:** Simple commands for complex plots.\n",
        "-   **Integration with Pandas:** Uses DataFrame columns for labels and grouping.\n",
        "-   **Built-in themes:** Attractive default color palettes and styles.\n",
        "-   **Statistical plots:** Includes KDE, violin, box, regression, joint, pair, and more.\n",
        "-   **Faceting:** Easily create grids of subplots by category.\n",
        "\n",
        "## Summary\n",
        "\n",
        "-   Seaborn streamlines statistical data visualization in Python, making it easier to create beautiful, informative graphics with minimal code.\n",
        "-   It is especially powerful for exploring and presenting relationships in complex datasets, and is a valuable addition to every data scientist’s toolkit\\[1\\]."
      ],
      "id": "36b2657f"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/yjtseng/.virtualenvs/r-reticulate/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}